import os
import re
import shutil
import subprocess
import tkinter as tk
from tkinter import filedialog, messagebox
from gblock import parse_fasta, gblock_pipeline, write_fasta, auto_align_if_needed  # â† auto_align_if_needed ì¶”ê°€
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

class ToolTip:
    def __init__(self, widget, text, delay_ms: int = 200):
        self.widget = widget
        self.text = text
        self.delay_ms = delay_ms
        self.tipwindow = None
        self._after_id = None
        widget.bind("<Enter>", self._schedule)
        widget.bind("<Leave>", self._cancel)

    def _schedule(self, _event=None):
        self._after_id = self.widget.after(self.delay_ms, self.show_tip)

    def _cancel(self, _event=None):
        if self._after_id:
            try:
                self.widget.after_cancel(self._after_id)
            except Exception:
                pass
            self._after_id = None
        self.hide_tip()

    def show_tip(self, event=None):
        if self.tipwindow or not self.text:
            return
        x = self.widget.winfo_rootx() + 25
        y = self.widget.winfo_rooty() + self.widget.winfo_height() + 5
        self.tipwindow = tw = tk.Toplevel(self.widget)
        tw.wm_overrideredirect(True)
        tw.wm_geometry(f"+{x}+{y}")
        label = tk.Label(
            tw,
            text=self.text,
            justify="left",
            background="#ffffe0",
            relief="solid",
            borderwidth=1,
            font=("ë§‘ì€ ê³ ë”•", 9),
            padx=6,
            pady=4,
            wraplength=360,
        )
        label.pack()

    def hide_tip(self, event=None):
        if self.tipwindow:
            try:
                self.tipwindow.destroy()
            except Exception:
                pass
            self.tipwindow = None

def create_tooltip(widget, text, delay_ms: int = 200):
    ToolTip(widget, text, delay_ms=delay_ms)

def write_txt(entries, path: str) -> None:
    with open(path, "w", encoding="utf-8") as out:
        for h, seq in entries:
            out.write(f">{h}\n{seq}\n")

def sanitize_label(header: str) -> str:
    """
    ë¼ë²¨ ì •ë¦¬
    """
    token = header.split()[0]
    token = re.sub(r"[^A-Za-z0-9._-]+", "", token)
    return token or "seq"

def write_pir_alignment(entries, path: str):
    """
    PIR(NBRF) í¬ë§·ìœ¼ë¡œ ì €ì¥. (Gblocks í˜¸í™˜ ë³´ìˆ˜ ì„¤ì •)
    ê° ì—”íŠ¸ë¦¬:
      >P1;label
      sequence title (í•œ ì¤„ ì•„ë¬´ í…ìŠ¤íŠ¸)
      SEQUENCE...
      *
    """
    with open(path, "w", encoding="utf-8") as f:
        for h, seq in entries:
            label = sanitize_label(h)
            if not label:
                label = "seq"
            f.write(f">P1;{label}\n")
            f.write("generated by gblocks-gui\n")
            s = seq.upper().replace(" ", "")
            for i in range(0, len(s), 60):
                f.write(s[i:i+60] + "\n")
            f.write("*\n")

def fmt_num(x: float) -> str:
    """
    íŒŒì¼ëª…ìš© ì‹¤ìˆ˜ í¬ë§·(ìµœëŒ€ ì†Œìˆ˜ì  2ìë¦¬, ë’¤ 0 ì œê±°)
    """
    s = f"{x:.2f}"
    s = s.rstrip("0").rstrip(".")
    return s if s else "0"

def map_b5_to_letter(mode: str) -> str:
    """
    GUIì˜ Gap Allowed ëª¨ë“œ ë§¤í•‘
    """
    mode = (mode or "").lower()
    if mode in ("none", "n"): return "n"
    if mode in ("half", "h"): return "h"
    if mode in ("all", "a"):  return "a"
    return "h"

def detect_data_type_by_chars(path: str) -> str:
    """
    íŒŒì¼ ë‚´ìš©ì„ í†µí•´ DNA(d) / Protein(p) ìë™ íŒì •.
    - DNA: A C G T N (ê·¸ë¦¬ê³  gap '-') ë§Œ ì£¼ë¡œ ìˆìœ¼ë©´ d
    - ê·¸ ì™¸ ë¬¸ìê°€ ì„ì´ë©´ p
    """
    dna = set("ACGTN-")
    aa  = set("ABCDEFGHIKLMNPQRSTVWY-")  # í‘œì¤€ ì•„ë¯¸ë…¸ì‚°
    dna_count = aa_count = other = 0
    try:
        with open(path, encoding="utf-8") as f:
            for line in f:
                s = line.strip().upper()
                if not s or s.startswith(">"):
                    continue
                for ch in s:
                    if ch in dna: dna_count += 1
                    elif ch in aa: aa_count += 1
                    else: other += 1
    except Exception:
        pass
    if dna_count > 0 and aa_count == 0 and other == 0:
        return "d"
    if aa_count > dna_count:
        return "p"
    return "p"

def find_gblocks_output(input_path: str) -> str | None:
    """
    Gblocksê°€ ìƒì„±í•  ìˆ˜ ìˆëŠ” ë‹¤ì–‘í•œ í›„ë³´ ì´ë¦„ì„ ëª¨ë‘ ê²€ì‚¬í•´ì„œ
    ì²« ë²ˆì§¸ë¡œ ì¡´ì¬í•˜ëŠ” ê²½ë¡œë¥¼ ë°˜í™˜. ì—†ìœ¼ë©´ None.
    """
    base = input_path
    stem, ext = os.path.splitext(base)
    candidates = [
        base + "-gb",
        base + "-gb.fasta",
        base + "-gb.fa",
        base + "-gb.faa",
        base + "-gb.txt",
        stem + "-gb" + ext,
        stem + "-gb.fasta",
        stem + "-gb.fa",
        stem + "-gb.faa",
        stem + "-gb.txt",
        base + "-gb.htm",
        stem + "-gb.htm",
    ]
    for c in candidates:
        if os.path.isfile(c):
            return c
    return None

def ensure_fasta_for_gblocks(src_path: str) -> tuple[str, str | None]:
    """
    .txt ì„ íƒ ì‹œ FASTA í—¤ë”(>...)ê°€ ë³´ì´ë©´ _tmp_for_gblocks.fasta ë¡œ ë³µì‚¬í•´
    ê·¸ ê²½ë¡œë¥¼ ë°˜í™˜. ì›ë³¸ì´ ì´ë¯¸ .fasta ê³„ì—´ì´ë©´ ê·¸ëŒ€ë¡œ ë°˜í™˜.
    """
    base, ext = os.path.splitext(src_path)
    if ext.lower() != ".txt":
        return src_path, None
    try:
        with open(src_path, encoding="utf-8") as f:
            first = f.readline().strip()
        if first.startswith(">"):
            tmp = base + "_tmp_for_gblocks.fasta"
            shutil.copy(src_path, tmp)
            return tmp, tmp
    except Exception:
        pass
    return src_path, None

# =========================
# GUI
# =========================
class GblockApp:
    def __init__(self, master, on_open_fetch=None):
        self.master = master
        self.on_open_fetch = on_open_fetch
        master.title("Gblocks GUI â€” Internal / External (Official Gblocks)")
        master.geometry("900x800")
        master.configure(bg="#f9f9f9")

        container = tk.Frame(master, bg="#f9f9f9")
        container.pack(fill="both", expand=True)

        canvas = tk.Canvas(container, bg="#f9f9f9", highlightthickness=0)
        vscroll = tk.Scrollbar(container, orient="vertical", command=canvas.yview)
        canvas.configure(yscrollcommand=vscroll.set)

        vscroll.pack(side="right", fill="y")
        canvas.pack(side="left", fill="both", expand=True)

        self.scrollable_frame = tk.Frame(canvas, bg="#f9f9f9")
        canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")

        def _update_scrollregion(_e=None):
            canvas.configure(scrollregion=canvas.bbox("all"))
        self.scrollable_frame.bind("<Configure>", _update_scrollregion)

        def _on_mousewheel(event):
            delta = event.delta
            if delta != 0:
                canvas.yview_scroll(int(-delta / 120), "units")
        canvas.bind_all("<MouseWheel>", _on_mousewheel)
        canvas.bind_all("<Button-4>", lambda e: canvas.yview_scroll(-1, "units"))  # Linux up
        canvas.bind_all("<Button-5>", lambda e: canvas.yview_scroll( 1, "units"))  # Linux down

        body = self.scrollable_frame

        title = tk.Label(
            body,
            text="ğŸ§¬ Gblocks-like Trimmer â€¢ Internal & External (Official Gblocks)",
            font=("Helvetica", 16, "bold"),
            bg="#f9f9f9",
        )
        title.pack(pady=12)

        topbar = tk.Frame(body, bg="#f9f9f9"); topbar.pack(pady=2)
        tk.Button(
            topbar,
            text= "NCBI Fetch (Protein)",
            command=(lambda: self.on_open_fetch() if callable(self.on_open_fetch) else None)
        ).pack()

        mode_frame = tk.Frame(body, bg="#f9f9f9")
        mode_frame.pack(pady=2)
        self.mode = tk.StringVar(value="internal")
        tk.Radiobutton(mode_frame, text="ë‚´ì¥ íŠ¸ë¦¬ë¨¸ (Python)",
                    variable=self.mode, value="internal", bg="#f9f9f9").pack(side=tk.LEFT, padx=8)
        tk.Radiobutton(mode_frame, text="ê³µì‹ Gblocks ì‹¤í–‰íŒŒì¼",
                    variable=self.mode, value="external", bg="#f9f9f9").pack(side=tk.LEFT, padx=8)

        self.file_path = tk.StringVar()
        frm_file = tk.Frame(body, bg="#f9f9f9")
        frm_file.pack(pady=6)
        ent_file = tk.Entry(frm_file, textvariable=self.file_path, width=64, state="readonly")
        ent_file.pack(side=tk.LEFT, padx=6)
        btn_file = tk.Button(frm_file, text="ì…ë ¥ íŒŒì¼ ì„ íƒ", command=self.select_file)
        btn_file.pack(side=tk.LEFT)
        create_tooltip(ent_file, "ì •ë ¬ ì „/í›„ì˜ FASTA ë˜ëŠ” TXT íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”. (í•„ìˆ˜)")

        exe_frame = tk.Frame(body, bg="#f9f9f9")
        exe_frame.pack(pady=4)
        self.gb_exe_path = tk.StringVar()
        ent_exe = tk.Entry(exe_frame, textvariable=self.gb_exe_path, width=64, state="readonly")
        ent_exe.pack(side=tk.LEFT, padx=6)
        btn_exe = tk.Button(exe_frame, text="Gblocks ì‹¤í–‰íŒŒì¼ ì„ íƒ", command=self.select_exe)
        btn_exe.pack(side=tk.LEFT)
        create_tooltip(ent_exe, "ê³µì‹ Gblocks ì‹¤í–‰íŒŒì¼ ê²½ë¡œ (ì˜ˆ: /usr/local/bin/Gblocks ë˜ëŠ” Gblocks.exe)")

        frm_internal = tk.LabelFrame(body, text="ë‚´ì¥ íŠ¸ë¦¬ë¨¸ íŒŒë¼ë¯¸í„° (ë‚´ì¥ íŠ¸ë¦¬ë¨¸ ì„ íƒ ì‹œ ì ìš©)", bg="#f9f9f9")
        frm_internal.pack(pady=8, padx=10, fill="x")

        self.min_block_len = tk.IntVar(value=5)
        self.max_gap       = tk.DoubleVar(value=0.7)
        self.min_cons      = tk.DoubleVar(value=0.5)
        self.flank_cons    = tk.DoubleVar(value=0.4)

        iparams = [
            ("ì—°ì†ëœ ë³´ì¡´ êµ¬ê°„ ìµœì†Œ ê¸¸ì´", self.min_block_len,
            "ë¹„ìŠ·í•œ ì—¼ê¸°(ë˜ëŠ” ì•„ë¯¸ë…¸ì‚°)ê°€ ëª‡ ê°œ ì´ìƒ ì—°ì†ë  ë•Œë¥¼\n'í•˜ë‚˜ì˜ ë³´ì¡´ êµ¬ê°„'ìœ¼ë¡œ ë³¼ì§€ ì •í•©ë‹ˆë‹¤.\nê°’ì´ í´ìˆ˜ë¡ ë” ê¸´ êµ¬ê°„ë§Œ ë‚¨ìŠµë‹ˆë‹¤."),
            ("gap í—ˆìš© ì •ë„ (0~1)", self.max_gap,
            "ì •ë ¬ëœ ì„œì—´ì—ì„œ '-'(ë¹ˆì¹¸, gap)ì„ ì–¼ë§ˆë‚˜ í—ˆìš©í• ì§€ ì •í•©ë‹ˆë‹¤.\n0ì´ë©´ gapì´ ìˆìœ¼ë©´ ë°”ë¡œ ì œì™¸, 1ì´ë©´ gapì´ ë§ì•„ë„ í†µê³¼í•©ë‹ˆë‹¤."),
            ("ë³´ì¡´ ë¹„ìœ¨ (0~1)", self.min_cons,
            "ê° ìœ„ì¹˜(ì—´)ì—ì„œ ê°™ì€ ë¬¸ìê°€ ë‚˜ì˜¬ ë¹„ìœ¨ì´\nì–¼ë§ˆ ì´ìƒì¼ ë•Œ 'ë³´ì¡´ëœ ì¹¼ëŸ¼'ìœ¼ë¡œ ì¸ì •í• ì§€ ì •í•©ë‹ˆë‹¤.\nì˜ˆ: 0.5 â†’ 50% ì´ìƒì´ ê°™ì•„ì•¼ í†µê³¼."),
            ("ì–‘ìª½ ëë¶€ë¶„ í’ˆì§ˆ (0~1)", self.flank_cons,
            "ë³´ì¡´ êµ¬ê°„ì˜ ì‹œì‘ê³¼ ëì´ ì–¼ë§ˆë‚˜ ì•ˆì •ì ì¸ì§€ë¥¼ í™•ì¸í•©ë‹ˆë‹¤.\nê°’ì´ ë†’ì„ìˆ˜ë¡ ê²½ê³„ê°€ ë” ê¹”ë”í•œ êµ¬ê°„ë§Œ ë‚¨ìŠµë‹ˆë‹¤."),
        ]

        for label, var, tip in iparams:
            row = tk.Frame(frm_internal, bg="#f9f9f9")
            row.pack(fill="x", pady=2)
            lbl = tk.Label(row, text=label, width=28, anchor="w", bg="#f9f9f9")
            lbl.pack(side=tk.LEFT, padx=10)
            ent = tk.Entry(row, textvariable=var, width=10)
            ent.pack(side=tk.LEFT)
            create_tooltip(lbl, tip); create_tooltip(ent, tip)

        frm_external = tk.LabelFrame(body, text="ê³µì‹ Gblocks íŒŒë¼ë¯¸í„° (ê³µì‹ Gblocks ì„ íƒ ì‹œ ì ìš©)", bg="#f9f9f9")
        frm_external.pack(pady=8, padx=10, fill="x")

        self.gb_t = tk.StringVar(value="")
        rowt = tk.Frame(frm_external, bg="#f9f9f9"); rowt.pack(fill="x", pady=2)
        tk.Label(rowt, text="Data type (-t)", width=28, anchor="w", bg="#f9f9f9").pack(side=tk.LEFT, padx=10)
        type_menu = tk.OptionMenu(rowt, self.gb_t, "", "p", "d")
        type_menu.pack(side=tk.LEFT)
        create_tooltip(rowt, "ë°ì´í„° íƒ€ì…. p=ë‹¨ë°±ì§ˆ, d=DNA. (ë¹„ì›Œë‘ë©´ ìë™ìœ¼ë¡œ íŒì •ë©ë‹ˆë‹¤.)")

        self.gb_b1 = tk.IntVar(value=9)
        self.gb_b2 = tk.IntVar(value=14)
        self.gb_b3 = tk.IntVar(value=8)
        self.gb_b4 = tk.IntVar(value=10)
        self.gb_b5_mode = tk.StringVar(value="Half")

        def spin_row(parent, label, var, tip):
            r = tk.Frame(parent, bg="#f9f9f9"); r.pack(fill="x", pady=2)
            tk.Label(r, text=label, width=28, anchor="w", bg="#f9f9f9").pack(side=tk.LEFT, padx=10)
            sp = tk.Spinbox(r, from_=0, to=9999, textvariable=var, width=8)
            sp.pack(side=tk.LEFT)
            create_tooltip(sp, tip); create_tooltip(r, tip)

        spin_row(frm_external, "b1 (Min # for Conserved)", self.gb_b1,
                "í•œ ìœ„ì¹˜(ì¹¼ëŸ¼)ê°€ 'ë³´ì¡´ëœ ìë¦¬'ë¡œ ì¸ì •ë˜ê¸° ìœ„í•œ ìµœì†Œ ì„œì—´ ê°œìˆ˜ì…ë‹ˆë‹¤.\n"
                "ì˜ˆ: 20ê°œ ì¤‘ 15ê°œê°€ ê°™ì€ ë¬¸ìì¸ ê²½ìš° â†’ 15 ì´ìƒì´ë©´ ë³´ì¡´ìœ¼ë¡œ ê°„ì£¼.")
        spin_row(frm_external, "b2 (Min # for Flanking)", self.gb_b2,
                "ë³´ì¡´ ë¸”ë¡ì˜ ì‹œì‘ê³¼ ë(ê²½ê³„ ë¶€ë¶„)ì„ ë³´ì¡´ëœ ê²ƒìœ¼ë¡œ\nì¸ì •í•˜ê¸° ìœ„í•œ ìµœì†Œ ì„œì—´ ê°œìˆ˜ì…ë‹ˆë‹¤.\n"
                "b1ë³´ë‹¤ ê°™ê±°ë‚˜ ì»¤ì•¼ í•©ë‹ˆë‹¤.")
        spin_row(frm_external, "b3 (Max contiguous non-conserved)", self.gb_b3,
                "ë¹„ìŠ·í•˜ì§€ ì•Šì€(ë³´ì¡´ë˜ì§€ ì•Šì€) ìë¦¬ê°€ ì—°ì†ìœ¼ë¡œ\nìµœëŒ€ ëª‡ ê°œê¹Œì§€ í—ˆìš©ë˜ëŠ”ì§€ë¥¼ ì •í•©ë‹ˆë‹¤.\n"
                "ê°’ì´ í¬ë©´ ëœ ë³´ì¡´ëœ êµ¬ê°„ë„ í¬í•¨ë©ë‹ˆë‹¤.")
        spin_row(frm_external, "b4 (Minimum block length)", self.gb_b4,
                "í•˜ë‚˜ì˜ ë³´ì¡´ ë¸”ë¡ìœ¼ë¡œ ì¸ì •ë˜ë ¤ë©´ ìµœì†Œ ëª‡ ê°œì˜ ì¹¼ëŸ¼ì´\nì—°ì†ë˜ì–´ì•¼ í•˜ëŠ”ì§€ë¥¼ ì •í•©ë‹ˆë‹¤.\n"
                "ì§§ì„ìˆ˜ë¡ ë¸”ë¡ì´ ì˜ê²Œ ë‚˜ë‰˜ê³ , ê¸¸ìˆ˜ë¡ í° ë©ì–´ë¦¬ë§Œ ë‚¨ìŠµë‹ˆë‹¤.")

        rowb5 = tk.Frame(frm_external, bg="#f9f9f9"); rowb5.pack(fill="x", pady=2)
        tk.Label(rowb5, text="b5 (Allowed Gap Positions)", width=28, anchor="w", bg="#f9f9f9").pack(side=tk.LEFT, padx=10)
        tk.OptionMenu(rowb5, self.gb_b5_mode, "None", "Half", "All").pack(side=tk.LEFT)
        create_tooltip(rowb5,
            "ê°­('-')ì´ í¬í•¨ëœ ì¹¼ëŸ¼ì„ ì–´ëŠ ì •ë„ í—ˆìš©í• ì§€ ì •í•©ë‹ˆë‹¤.\n"
            "â€¢ None: ê°­ì´ ìˆìœ¼ë©´ ë°”ë¡œ ì œì™¸\n"
            "â€¢ Half: ì ˆë°˜ ì •ë„ê¹Œì§„ í—ˆìš©\n"
            "â€¢ All: ëŒ€ë¶€ë¶„ ê°­ì´ì–´ë„ í—ˆìš©")

        btn_run = tk.Button(body, text="ì‹¤í–‰", command=self.run,
                            bg="#4CAF50", fg="white", font=("Helvetica", 11, "bold"))
        btn_run.pack(pady=12)
        create_tooltip(btn_run, "ì„ íƒí•œ ëª¨ë“œ(ë‚´ì¥/ì™¸ë¶€)ë¡œ íŠ¸ë¦¬ë°ì„ ì‹¤í–‰í•©ë‹ˆë‹¤.")

        self.status = tk.Label(body, text="ì…ë ¥ íŒŒì¼ì„ ì„ íƒí•œ í›„ ì‹¤í–‰í•˜ì„¸ìš”.", bg="#f9f9f9", fg="#333")
        self.status.pack()

        self.fig, self.ax = plt.subplots(figsize=(6.6, 2.6))
        self.canvas = FigureCanvasTkAgg(self.fig, master=body)
        self.canvas.get_tk_widget().pack(pady=10)

        self.out_paths_box = tk.Text(body, height=8, width=106)
        self.out_paths_box.configure(state="disabled")
        self.out_paths_box.pack(padx=10, pady=6)

    def select_file(self):
        path = filedialog.askopenfilename(
            title="FASTA ë˜ëŠ” TXT íŒŒì¼ ì„ íƒ",
            filetypes=[("FASTA or TXT files", "*.fasta *.fa *.faa *.txt"), ("All files", "*.*")]
        )
        if path:
            self.file_path.set(path)
            self.status.config(text=f"ì„ íƒëœ íŒŒì¼: {os.path.basename(path)}")

    def select_exe(self):
        path = filedialog.askopenfilename(
            title="Gblocks ì‹¤í–‰íŒŒì¼ ì„ íƒ",
            filetypes=[("Executable", "*"), ("All files", "*.*")]
        )
        if path:
            self.gb_exe_path.set(path)
            self.status.config(text=f"Gblocks ì‹¤í–‰íŒŒì¼: {path}")

    def run(self):
        mode = self.mode.get()
        if mode == "internal":
            self.run_internal()
        else:
            self.run_external()

    def run_internal(self):
        path = self.file_path.get()
        if not path:
            messagebox.showwarning("ê²½ê³ ", "ì…ë ¥ íŒŒì¼ì„ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”.")
            return
        try:
            mbl   = int(self.min_block_len.get())
            gap   = float(self.max_gap.get())
            cons  = float(self.min_cons.get())
            flank = float(self.flank_cons.get())

            entries = parse_fasta(path)
            nseq = len(entries)
            seq_len_before = len(entries[0][1]) if entries else 0

            trimmed = gblock_pipeline(
                entries,
                auto_align=True,
                aligner="auto",
                min_block_len=mbl,
                max_gap=gap,
                min_cons=cons,
                flank_cons=flank,
                drop_all_gap_columns=True,
            )

            params_tag = f"_m{mbl}_g{fmt_num(gap)}_c{fmt_num(cons)}_f{fmt_num(flank)}"
            base = os.path.splitext(path)[0]
            out_dir = base + params_tag
            os.makedirs(out_dir, exist_ok=True)

            out_fasta = os.path.join(out_dir, "trimmed.fasta")
            out_txt   = os.path.join(out_dir, "trimmed.txt")
            mega_fa   = os.path.join(out_dir, "trimmed_mega.fasta")
            map_txt   = os.path.join(out_dir, "label_map.txt")

            write_fasta(trimmed, out_fasta)
            with open(out_txt, "w", encoding="utf-8") as m:
                for h, seq in trimmed:
                    m.write(f">{h}\n{seq}\n")

            cleaned = [(sanitize_label(h), seq) for h, seq in trimmed]
            write_fasta(cleaned, mega_fa)
            with open(map_txt, "w", encoding="utf-8") as m:
                m.write("original\tsanitized\n")
                for (h, _), (hh, _) in zip(trimmed, cleaned):
                    m.write(f"{h}\t{hh}\n")

            seq_len_after = len(trimmed[0][1]) if trimmed else 0
            reduction = (1 - seq_len_after / max(1, seq_len_before)) * 100.0
            self._plot(seq_len_before, seq_len_after, nseq)

            self.status.config(
                text=f"âœ… ì‹¤í–‰ ì™„ë£Œ ({seq_len_before} â†’ {seq_len_after}, -{reduction:.1f}%)\n"
                    f"í´ë”: {os.path.basename(out_dir)}"
            )
            self._write_paths([
                ("FASTA (ì›ë³¸ ë¼ë²¨)", out_fasta),
                ("TXT", out_txt),
                ("MEGAìš© FASTA (ì´ë¦„ë§Œ)", mega_fa),
                ("ë¼ë²¨ ë§¤í•‘", map_txt),
            ])

        except Exception as e:
            messagebox.showerror("ì—ëŸ¬", str(e))
            self.status.config(text="âŒ ì˜¤ë¥˜")

    def run_external(self):
        path_in = self.file_path.get()
        exe  = self.gb_exe_path.get()
        if not path_in:
            messagebox.showwarning("ê²½ê³ ", "ì…ë ¥ íŒŒì¼ì„ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”.")
            return
        if not exe or not os.path.isfile(exe):
            messagebox.showwarning("ê²½ê³ ", "Gblocks ì‹¤í–‰íŒŒì¼ ê²½ë¡œë¥¼ ì§€ì •í•˜ì„¸ìš”.")
            return

        workdir = os.path.dirname(os.path.abspath(path_in)) or "."
        path_src, tmp_txt_copy = ensure_fasta_for_gblocks(path_in)

        aligned_tmp = None
        pir_tmp = None
        try:
            entries = parse_fasta(path_src)
            aligned = auto_align_if_needed(entries, aligner="auto", fallback_align=True)
            L0 = len(aligned[0][1]) if aligned else 0
            if not all(len(s) == L0 for _, s in aligned):
                raise RuntimeError("ì •ë ¬ ì‹¤íŒ¨: ë™ì¼ ê¸¸ì´ê°€ ì•„ë‹™ë‹ˆë‹¤. (MAFFT/MUSCLE ì„¤ì¹˜/ê²½ë¡œ ë˜ëŠ” ì…ë ¥ í™•ì¸)")
            if len(aligned) < 2:
                raise RuntimeError("ì™¸ë¶€ GblocksëŠ” ìµœì†Œ 2ê°œ ì´ìƒì˜ ì •ë ¬ ì„œì—´ì´ í•„ìš”í•©ë‹ˆë‹¤. (í˜„ì¬ 1ê°œ)")
            aligned_tmp = os.path.splitext(path_src)[0] + "_tmp_aligned_for_gblocks.fasta"
            write_fasta(aligned, aligned_tmp, wrap=0)

            pir_tmp = os.path.splitext(path_src)[0] + "_tmp_aligned_for_gblocks.pir"
            write_pir_alignment(aligned, pir_tmp)

            t_letter = (self.gb_t.get() or "").strip().lower()
            if t_letter not in ("p", "d"):
                t_letter = detect_data_type_by_chars(aligned_tmp)

            N = len(aligned)
            b1 = min(int(self.gb_b1.get()), N)
            b2 = min(int(self.gb_b2.get()), N)
            if b1 > b2:
                b1 = b2
            b3 = int(self.gb_b3.get())
            b4 = int(self.gb_b4.get())
            b5_letter = map_b5_to_letter(self.gb_b5_mode.get())

            pir_arg = os.path.basename(pir_tmp)
            cmd = [exe, pir_arg, f"-t={t_letter}", f"-b1={b1}", f"-b2={b2}",
                f"-b3={b3}", f"-b4={b4}", f"-b5={b5_letter}"]
            completed = subprocess.run(cmd, cwd=workdir,
                                    stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

            gb_out = find_gblocks_output(os.path.join(workdir, pir_arg))
            if not gb_out:
                err_txt = (
                    "Gblocks ì‹¤í–‰ ì‹¤íŒ¨\n\n"
                    f"rc={completed.returncode}\n"
                    f"STDOUT:\n{completed.stdout}\n\nSTDERR:\n{completed.stderr}\n"
                )
                raise RuntimeError(err_txt)

            if gb_out.lower().endswith((".htm", ".html")):
                raise RuntimeError(
                    "ì´ Gblocks ë°°í¬ë³¸ì€ HTMLë§Œ ìƒì„±í•©ë‹ˆë‹¤.\n"
                    "í…ìŠ¤íŠ¸ ê²°ê³¼ê°€ í•„ìš”í•œ ê²½ìš° ë‹¤ë¥¸ Gblocks ì‹¤í–‰íŒŒì¼ì„ ì‚¬ìš©í•˜ì„¸ìš”."
                )

            trimmed = parse_fasta(gb_out)
            seq_len_before = len(aligned[0][1]) if aligned else 0
            seq_len_after  = len(trimmed[0][1]) if trimmed else 0
            reduction = (1 - (seq_len_after / max(1, seq_len_before))) * 100.0

            btag = f"_GB_t{t_letter}_b1{b1}_b2{b2}_b3{b3}_b4{b4}_b5{b5_letter}"
            base = os.path.splitext(path_in)[0]
            out_dir = base + btag
            os.makedirs(out_dir, exist_ok=True)

            out_fasta = os.path.join(out_dir, "trimmed.fasta")
            out_txt   = os.path.join(out_dir, "trimmed.txt")
            mega_fa   = os.path.join(out_dir, "trimmed_mega.fasta")
            map_txt   = os.path.join(out_dir, "label_map.txt")
            gb_raw_copy = os.path.join(out_dir, os.path.basename(gb_out))
            try:
                shutil.copy(gb_out, gb_raw_copy)
            except Exception:
                gb_raw_copy = gb_out

            write_fasta(trimmed, out_fasta)
            with open(out_txt, "w", encoding="utf-8") as m:
                for h, seq in trimmed:
                    m.write(f">{h}\n{seq}\n")

            cleaned = [(sanitize_label(h), seq) for h, seq in trimmed]
            write_fasta(cleaned, mega_fa)
            with open(map_txt, "w", encoding="utf-8") as m:
                m.write("original\tsanitized\n")
                for (h, _), (hh, _) in zip(trimmed, cleaned):
                    m.write(f"{h}\t{hh}\n")

            self._plot(seq_len_before, seq_len_after, len(aligned))
            summary = completed.stdout.strip()
            if summary:
                self.status.config(
                    text=f"âœ… Gblocks ì™„ë£Œ â€” {seq_len_before} â†’ {seq_len_after} (-{reduction:.1f}%)\n"
                        f"{summary}\ní´ë”: {os.path.basename(out_dir)}"
                )
            else:
                self.status.config(
                    text=f"âœ… Gblocks ì™„ë£Œ â€” {seq_len_before} â†’ {seq_len_after} (-{reduction:.1f}%)\n"
                        f"í´ë”: {os.path.basename(out_dir)}"
                )

            self._write_paths([
                ("FASTA (ì›ë³¸ ë¼ë²¨)", out_fasta),
                ("TXT", out_txt),
                ("MEGAìš© FASTA (ì´ë¦„ë§Œ)", mega_fa),
                ("ë¼ë²¨ ë§¤í•‘", map_txt),
                ("ì›ë³¸ Gblocks ì¶œë ¥(ì°¸ì¡°)", gb_raw_copy),
            ])

        except Exception as e:
            messagebox.showerror("ì—ëŸ¬", str(e))
            self.status.config(text="âŒ Gblocks ì‹¤í–‰ ì˜¤ë¥˜")
        finally:
            for tmp in (tmp_txt_copy, aligned_tmp, pir_tmp):
                try:
                    if tmp and os.path.isfile(tmp):
                        os.remove(tmp)
                except Exception:
                    pass


    # ---------- ì‹œê°í™”/ê²½ë¡œ ì¶œë ¥ ----------
    def _plot(self, before_len, after_len, nseq):
        self.ax.clear()
        self.ax.bar(["Before", "After"], [before_len, after_len], color=["#FF7043", "#66BB6A"])
        self.ax.set_ylabel("Sequence Length")
        self.ax.set_title(f"{nseq} sequences processed")
        self.canvas.draw()

    def _write_paths(self, items):
        self.out_paths_box.configure(state="normal")
        self.out_paths_box.delete("1.0", "end")
        for label, p in items:
            self.out_paths_box.insert("end", f"{label}: {os.path.abspath(p)}\n")
        self.out_paths_box.configure(state="disabled")


if __name__ == "__main__":
    try:
        import matplotlib
        matplotlib.use("TkAgg")
    except Exception:
        pass
    root = tk.Tk()
    app = GblockApp(root)
    root.mainloop()