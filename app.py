import os
import re
import shutil
import subprocess
import tkinter as tk
from tkinter import filedialog, messagebox
from gblock import parse_fasta, gblock_pipeline, write_fasta, auto_align_if_needed  # ‚Üê auto_align_if_needed Ï∂îÍ∞Ä
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

class ToolTip:
    def __init__(self, widget, text, delay_ms: int = 200):
        self.widget = widget
        self.text = text
        self.delay_ms = delay_ms
        self.tipwindow = None
        self._after_id = None
        widget.bind("<Enter>", self._schedule)
        widget.bind("<Leave>", self._cancel)

    def _schedule(self, _event=None):
        self._after_id = self.widget.after(self.delay_ms, self.show_tip)

    def _cancel(self, _event=None):
        if self._after_id:
            try:
                self.widget.after_cancel(self._after_id)
            except Exception:
                pass
            self._after_id = None
        self.hide_tip()

    def show_tip(self, event=None):
        if self.tipwindow or not self.text:
            return
        x = self.widget.winfo_rootx() + 25
        y = self.widget.winfo_rooty() + self.widget.winfo_height() + 5
        self.tipwindow = tw = tk.Toplevel(self.widget)
        tw.wm_overrideredirect(True)
        tw.wm_geometry(f"+{x}+{y}")
        label = tk.Label(
            tw,
            text=self.text,
            justify="left",
            background="#ffffe0",
            relief="solid",
            borderwidth=1,
            font=("ÎßëÏùÄ Í≥†Îîï", 9),
            padx=6,
            pady=4,
            wraplength=360,
        )
        label.pack()

    def hide_tip(self, event=None):
        if self.tipwindow:
            try:
                self.tipwindow.destroy()
            except Exception:
                pass
            self.tipwindow = None

def create_tooltip(widget, text, delay_ms: int = 200):
    ToolTip(widget, text, delay_ms=delay_ms)

def write_txt(entries, path: str) -> None:
    with open(path, "w", encoding="utf-8") as out:
        for h, seq in entries:
            out.write(f">{h}\n{seq}\n")

def sanitize_label(header: str) -> str:
    """
    ÎùºÎ≤® Ï†ïÎ¶¨
    """
    token = header.split()[0]
    token = re.sub(r"[^A-Za-z0-9._-]+", "", token)
    return token or "seq"

def write_pir_alignment(entries, path: str):
    """
    PIR(NBRF) Ìè¨Îß∑ÏúºÎ°ú Ï†ÄÏû•.
    > Í≥µÏãù GBlocksÏö©Ïö©
    """
    with open(path, "w", encoding="utf-8") as f:
        for h, seq in entries:
            label = sanitize_label(h)
            f.write(f">P1;{label}\n")
            f.write("generated by gblocks-gui\n")
            s = seq.upper()
            for i in range(0, len(s), 60):
                f.write(s[i:i+60] + "\n")
            f.write("*\n")

def fmt_num(x: float) -> str:
    """
    ÌååÏùºÎ™ÖÏö© Ïã§Ïàò Ìè¨Îß∑(ÏµúÎåÄ ÏÜåÏàòÏ†ê 2ÏûêÎ¶¨, Îí§ 0 Ï†úÍ±∞)
    """
    s = f"{x:.2f}"
    s = s.rstrip("0").rstrip(".")
    return s if s else "0"

def map_b5_to_letter(mode: str) -> str:
    """
    GUIÏùò Gap Allowed Î™®Îìú Îß§Ìïë
    """
    mode = (mode or "").lower()
    if mode in ("none", "n"): return "n"
    if mode in ("half", "h"): return "h"
    if mode in ("all", "a"):  return "a"
    return "h"

def detect_data_type_by_chars(path: str) -> str:
    """
    ÌååÏùº ÎÇ¥Ïö©ÏùÑ ÌÜµÌï¥ DNA(d) / Protein(p) ÏûêÎèô ÌåêÏ†ï.
    - DNA: A C G T N (Í∑∏Î¶¨Í≥† gap '-') Îßå Ï£ºÎ°ú ÏûàÏúºÎ©¥ d
    - Í∑∏ Ïô∏ Î¨∏ÏûêÍ∞Ä ÏÑûÏù¥Î©¥ p
    """
    dna = set("ACGTN-")
    aa  = set("ABCDEFGHIKLMNPQRSTVWY-")  # ÌëúÏ§Ä ÏïÑÎØ∏ÎÖ∏ÏÇ∞
    dna_count = aa_count = other = 0
    try:
        with open(path, encoding="utf-8") as f:
            for line in f:
                s = line.strip().upper()
                if not s or s.startswith(">"):
                    continue
                for ch in s:
                    if ch in dna: dna_count += 1
                    elif ch in aa: aa_count += 1
                    else: other += 1
    except Exception:
        pass
    if dna_count > 0 and aa_count == 0 and other == 0:
        return "d"
    if aa_count > dna_count:
        return "p"
    return "p"

def find_gblocks_output(input_path: str) -> str | None:
    """
    GblocksÍ∞Ä ÏÉùÏÑ±Ìï† Ïàò ÏûàÎäî Îã§ÏñëÌïú ÌõÑÎ≥¥ Ïù¥Î¶ÑÏùÑ Î™®Îëê Í≤ÄÏÇ¨Ìï¥ÏÑú
    Ï≤´ Î≤àÏß∏Î°ú Ï°¥Ïû¨ÌïòÎäî Í≤ΩÎ°úÎ•º Î∞òÌôò. ÏóÜÏúºÎ©¥ None.
    """
    base = input_path
    stem, ext = os.path.splitext(base)
    candidates = [
        base + "-gb",
        base + "-gb.fasta",
        base + "-gb.fa",
        base + "-gb.faa",
        base + "-gb.txt",
        stem + "-gb" + ext,
        stem + "-gb.fasta",
        stem + "-gb.fa",
        stem + "-gb.faa",
        stem + "-gb.txt",
        base + "-gb.htm",
        stem + "-gb.htm",
    ]
    for c in candidates:
        if os.path.isfile(c):
            return c
    return None

def ensure_fasta_for_gblocks(src_path: str) -> tuple[str, str | None]:
    """
    .txt ÏÑ†ÌÉù Ïãú FASTA Ìó§Îçî(>...)Í∞Ä Î≥¥Ïù¥Î©¥ _tmp_for_gblocks.fasta Î°ú Î≥µÏÇ¨Ìï¥
    Í∑∏ Í≤ΩÎ°úÎ•º Î∞òÌôò. ÏõêÎ≥∏Ïù¥ Ïù¥ÎØ∏ .fasta Í≥ÑÏó¥Ïù¥Î©¥ Í∑∏ÎåÄÎ°ú Î∞òÌôò.
    """
    base, ext = os.path.splitext(src_path)
    if ext.lower() != ".txt":
        return src_path, None
    try:
        with open(src_path, encoding="utf-8") as f:
            first = f.readline().strip()
        if first.startswith(">"):
            tmp = base + "_tmp_for_gblocks.fasta"
            shutil.copy(src_path, tmp)
            return tmp, tmp
    except Exception:
        pass
    return src_path, None

# =========================
# GUI
# =========================
class GblockApp:
    def __init__(self, master):
        self.master = master
        master.title("Gblocks GUI ‚Äî Internal / External (Official Gblocks)")
        master.geometry("900x800")
        master.configure(bg="#f9f9f9")

        container = tk.Frame(master, bg="#f9f9f9")
        container.pack(fill="both", expand=True)

        canvas = tk.Canvas(container, bg="#f9f9f9", highlightthickness=0)
        vscroll = tk.Scrollbar(container, orient="vertical", command=canvas.yview)
        canvas.configure(yscrollcommand=vscroll.set)

        vscroll.pack(side="right", fill="y")
        canvas.pack(side="left", fill="both", expand=True)

        self.scrollable_frame = tk.Frame(canvas, bg="#f9f9f9")
        canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")

        def _update_scrollregion(_e=None):
            canvas.configure(scrollregion=canvas.bbox("all"))
        self.scrollable_frame.bind("<Configure>", _update_scrollregion)

        def _on_mousewheel(event):
            delta = event.delta
            if delta != 0:
                canvas.yview_scroll(int(-delta / 120), "units")
        canvas.bind_all("<MouseWheel>", _on_mousewheel)
        canvas.bind_all("<Button-4>", lambda e: canvas.yview_scroll(-1, "units"))  # Linux up
        canvas.bind_all("<Button-5>", lambda e: canvas.yview_scroll( 1, "units"))  # Linux down

        body = self.scrollable_frame

        title = tk.Label(
            body,
            text="üß¨ Gblocks-like Trimmer ‚Ä¢ Internal & External (Official Gblocks)",
            font=("Helvetica", 16, "bold"),
            bg="#f9f9f9",
        )
        title.pack(pady=12)

        mode_frame = tk.Frame(body, bg="#f9f9f9")
        mode_frame.pack(pady=2)
        self.mode = tk.StringVar(value="internal")
        tk.Radiobutton(mode_frame, text="ÎÇ¥Ïû• Ìä∏Î¶¨Î®∏ (Python)",
                       variable=self.mode, value="internal", bg="#f9f9f9").pack(side=tk.LEFT, padx=8)
        tk.Radiobutton(mode_frame, text="Í≥µÏãù Gblocks Ïã§ÌñâÌååÏùº",
                       variable=self.mode, value="external", bg="#f9f9f9").pack(side=tk.LEFT, padx=8)

        self.file_path = tk.StringVar()
        frm_file = tk.Frame(body, bg="#f9f9f9")
        frm_file.pack(pady=6)
        ent_file = tk.Entry(frm_file, textvariable=self.file_path, width=64, state="readonly")
        ent_file.pack(side=tk.LEFT, padx=6)
        btn_file = tk.Button(frm_file, text="ÏûÖÎ†• ÌååÏùº ÏÑ†ÌÉù", command=self.select_file)
        btn_file.pack(side=tk.LEFT)
        create_tooltip(ent_file, "Ï†ïÎ†¨ Ï†Ñ/ÌõÑÏùò FASTA ÎòêÎäî TXT ÌååÏùºÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî. (ÌïÑÏàò)")

        exe_frame = tk.Frame(body, bg="#f9f9f9")
        exe_frame.pack(pady=4)
        self.gb_exe_path = tk.StringVar()
        ent_exe = tk.Entry(exe_frame, textvariable=self.gb_exe_path, width=64, state="readonly")
        ent_exe.pack(side=tk.LEFT, padx=6)
        btn_exe = tk.Button(exe_frame, text="Gblocks Ïã§ÌñâÌååÏùº ÏÑ†ÌÉù", command=self.select_exe)
        btn_exe.pack(side=tk.LEFT)
        create_tooltip(ent_exe, "Í≥µÏãù Gblocks Ïã§ÌñâÌååÏùº Í≤ΩÎ°ú (Ïòà: /usr/local/bin/Gblocks ÎòêÎäî Gblocks.exe)")

        frm_internal = tk.LabelFrame(body, text="ÎÇ¥Ïû• Ìä∏Î¶¨Î®∏ ÌååÎùºÎØ∏ÌÑ∞ (ÎÇ¥Ïû• Ìä∏Î¶¨Î®∏ ÏÑ†ÌÉù Ïãú Ï†ÅÏö©)", bg="#f9f9f9")
        frm_internal.pack(pady=8, padx=10, fill="x")

        self.min_block_len = tk.IntVar(value=5)
        self.max_gap       = tk.DoubleVar(value=0.7)
        self.min_cons      = tk.DoubleVar(value=0.5)
        self.flank_cons    = tk.DoubleVar(value=0.4)

        iparams = [
            ("Ïó∞ÏÜçÎêú Î≥¥Ï°¥ Íµ¨Í∞Ñ ÏµúÏÜå Í∏∏Ïù¥", self.min_block_len,
             "ÎπÑÏä∑Ìïú ÏóºÍ∏∞(ÎòêÎäî ÏïÑÎØ∏ÎÖ∏ÏÇ∞)Í∞Ä Î™á Í∞ú Ïù¥ÏÉÅ Ïó∞ÏÜçÎê† ÎïåÎ•º\n'ÌïòÎÇòÏùò Î≥¥Ï°¥ Íµ¨Í∞Ñ'ÏúºÎ°ú Î≥ºÏßÄ Ï†ïÌï©ÎãàÎã§.\nÍ∞íÏù¥ ÌÅ¥ÏàòÎ°ù Îçî Í∏¥ Íµ¨Í∞ÑÎßå ÎÇ®ÏäµÎãàÎã§."),
            ("gap ÌóàÏö© Ï†ïÎèÑ (0~1)", self.max_gap,
             "Ï†ïÎ†¨Îêú ÏÑúÏó¥ÏóêÏÑú '-'(ÎπàÏπ∏, gap)ÏùÑ ÏñºÎßàÎÇò ÌóàÏö©Ìï†ÏßÄ Ï†ïÌï©ÎãàÎã§.\n0Ïù¥Î©¥ gapÏù¥ ÏûàÏúºÎ©¥ Î∞îÎ°ú Ï†úÏô∏, 1Ïù¥Î©¥ gapÏù¥ ÎßéÏïÑÎèÑ ÌÜµÍ≥ºÌï©ÎãàÎã§."),
            ("Î≥¥Ï°¥ ÎπÑÏú® (0~1)", self.min_cons,
             "Í∞Å ÏúÑÏπò(Ïó¥)ÏóêÏÑú Í∞ôÏùÄ Î¨∏ÏûêÍ∞Ä ÎÇòÏò¨ ÎπÑÏú®Ïù¥\nÏñºÎßà Ïù¥ÏÉÅÏùº Îïå 'Î≥¥Ï°¥Îêú ÏπºÎüº'ÏúºÎ°ú Ïù∏Ï†ïÌï†ÏßÄ Ï†ïÌï©ÎãàÎã§.\nÏòà: 0.5 ‚Üí 50% Ïù¥ÏÉÅÏù¥ Í∞ôÏïÑÏïº ÌÜµÍ≥º."),
            ("ÏñëÏ™Ω ÎÅùÎ∂ÄÎ∂Ñ ÌíàÏßà (0~1)", self.flank_cons,
             "Î≥¥Ï°¥ Íµ¨Í∞ÑÏùò ÏãúÏûëÍ≥º ÎÅùÏù¥ ÏñºÎßàÎÇò ÏïàÏ†ïÏ†ÅÏù∏ÏßÄÎ•º ÌôïÏù∏Ìï©ÎãàÎã§.\nÍ∞íÏù¥ ÎÜíÏùÑÏàòÎ°ù Í≤ΩÍ≥ÑÍ∞Ä Îçî ÍπîÎÅîÌïú Íµ¨Í∞ÑÎßå ÎÇ®ÏäµÎãàÎã§."),
        ]

        for label, var, tip in iparams:
            row = tk.Frame(frm_internal, bg="#f9f9f9")
            row.pack(fill="x", pady=2)
            lbl = tk.Label(row, text=label, width=28, anchor="w", bg="#f9f9f9")
            lbl.pack(side=tk.LEFT, padx=10)
            ent = tk.Entry(row, textvariable=var, width=10)
            ent.pack(side=tk.LEFT)
            create_tooltip(lbl, tip); create_tooltip(ent, tip)

        frm_external = tk.LabelFrame(body, text="Í≥µÏãù Gblocks ÌååÎùºÎØ∏ÌÑ∞ (Í≥µÏãù Gblocks ÏÑ†ÌÉù Ïãú Ï†ÅÏö©)", bg="#f9f9f9")
        frm_external.pack(pady=8, padx=10, fill="x")

        self.gb_t = tk.StringVar(value="")
        rowt = tk.Frame(frm_external, bg="#f9f9f9"); rowt.pack(fill="x", pady=2)
        tk.Label(rowt, text="Data type (-t)", width=28, anchor="w", bg="#f9f9f9").pack(side=tk.LEFT, padx=10)
        type_menu = tk.OptionMenu(rowt, self.gb_t, "", "p", "d")
        type_menu.pack(side=tk.LEFT)
        create_tooltip(rowt, "Îç∞Ïù¥ÌÑ∞ ÌÉÄÏûÖ. p=Îã®Î∞±Ïßà, d=DNA. (ÎπÑÏõåÎëêÎ©¥ ÏûêÎèôÏúºÎ°ú ÌåêÏ†ïÎê©ÎãàÎã§.)")

        self.gb_b1 = tk.IntVar(value=9)
        self.gb_b2 = tk.IntVar(value=14)
        self.gb_b3 = tk.IntVar(value=8)
        self.gb_b4 = tk.IntVar(value=10)
        self.gb_b5_mode = tk.StringVar(value="Half")

        def spin_row(parent, label, var, tip):
            r = tk.Frame(parent, bg="#f9f9f9"); r.pack(fill="x", pady=2)
            tk.Label(r, text=label, width=28, anchor="w", bg="#f9f9f9").pack(side=tk.LEFT, padx=10)
            sp = tk.Spinbox(r, from_=0, to=9999, textvariable=var, width=8)
            sp.pack(side=tk.LEFT)
            create_tooltip(sp, tip); create_tooltip(r, tip)

        spin_row(frm_external, "b1 (Min # for Conserved)", self.gb_b1,
                 "Ìïú ÏúÑÏπò(ÏπºÎüº)Í∞Ä 'Î≥¥Ï°¥Îêú ÏûêÎ¶¨'Î°ú Ïù∏Ï†ïÎêòÍ∏∞ ÏúÑÌïú ÏµúÏÜå ÏÑúÏó¥ Í∞úÏàòÏûÖÎãàÎã§.\n"
                 "Ïòà: 20Í∞ú Ï§ë 15Í∞úÍ∞Ä Í∞ôÏùÄ Î¨∏ÏûêÏù∏ Í≤ΩÏö∞ ‚Üí 15 Ïù¥ÏÉÅÏù¥Î©¥ Î≥¥Ï°¥ÏúºÎ°ú Í∞ÑÏ£º.")
        spin_row(frm_external, "b2 (Min # for Flanking)", self.gb_b2,
                 "Î≥¥Ï°¥ Î∏îÎ°ùÏùò ÏãúÏûëÍ≥º ÎÅù(Í≤ΩÍ≥Ñ Î∂ÄÎ∂Ñ)ÏùÑ Î≥¥Ï°¥Îêú Í≤ÉÏúºÎ°ú\nÏù∏Ï†ïÌïòÍ∏∞ ÏúÑÌïú ÏµúÏÜå ÏÑúÏó¥ Í∞úÏàòÏûÖÎãàÎã§.\n"
                 "b1Î≥¥Îã§ Í∞ôÍ±∞ÎÇò Ïª§Ïïº Ìï©ÎãàÎã§.")
        spin_row(frm_external, "b3 (Max contiguous non-conserved)", self.gb_b3,
                 "ÎπÑÏä∑ÌïòÏßÄ ÏïäÏùÄ(Î≥¥Ï°¥ÎêòÏßÄ ÏïäÏùÄ) ÏûêÎ¶¨Í∞Ä Ïó∞ÏÜçÏúºÎ°ú\nÏµúÎåÄ Î™á Í∞úÍπåÏßÄ ÌóàÏö©ÎêòÎäîÏßÄÎ•º Ï†ïÌï©ÎãàÎã§.\n"
                 "Í∞íÏù¥ ÌÅ¨Î©¥ Îçú Î≥¥Ï°¥Îêú Íµ¨Í∞ÑÎèÑ Ìè¨Ìï®Îê©ÎãàÎã§.")
        spin_row(frm_external, "b4 (Minimum block length)", self.gb_b4,
                 "ÌïòÎÇòÏùò Î≥¥Ï°¥ Î∏îÎ°ùÏúºÎ°ú Ïù∏Ï†ïÎêòÎ†§Î©¥ ÏµúÏÜå Î™á Í∞úÏùò ÏπºÎüºÏù¥\nÏó∞ÏÜçÎêòÏñ¥Ïïº ÌïòÎäîÏßÄÎ•º Ï†ïÌï©ÎãàÎã§.\n"
                 "ÏßßÏùÑÏàòÎ°ù Î∏îÎ°ùÏù¥ ÏûòÍ≤å ÎÇòÎâòÍ≥†, Í∏∏ÏàòÎ°ù ÌÅ∞ Îç©Ïñ¥Î¶¨Îßå ÎÇ®ÏäµÎãàÎã§.")

        rowb5 = tk.Frame(frm_external, bg="#f9f9f9"); rowb5.pack(fill="x", pady=2)
        tk.Label(rowb5, text="b5 (Allowed Gap Positions)", width=28, anchor="w", bg="#f9f9f9").pack(side=tk.LEFT, padx=10)
        tk.OptionMenu(rowb5, self.gb_b5_mode, "None", "Half", "All").pack(side=tk.LEFT)
        create_tooltip(rowb5,
            "Í∞≠('-')Ïù¥ Ìè¨Ìï®Îêú ÏπºÎüºÏùÑ Ïñ¥Îäê Ï†ïÎèÑ ÌóàÏö©Ìï†ÏßÄ Ï†ïÌï©ÎãàÎã§.\n"
            "‚Ä¢ None: Í∞≠Ïù¥ ÏûàÏúºÎ©¥ Î∞îÎ°ú Ï†úÏô∏\n"
            "‚Ä¢ Half: Ï†àÎ∞ò Ï†ïÎèÑÍπåÏßÑ ÌóàÏö©\n"
            "‚Ä¢ All: ÎåÄÎ∂ÄÎ∂Ñ Í∞≠Ïù¥Ïñ¥ÎèÑ ÌóàÏö©")

        btn_run = tk.Button(body, text="Ïã§Ìñâ", command=self.run,
                            bg="#4CAF50", fg="white", font=("Helvetica", 11, "bold"))
        btn_run.pack(pady=12)
        create_tooltip(btn_run, "ÏÑ†ÌÉùÌïú Î™®Îìú(ÎÇ¥Ïû•/Ïô∏Î∂Ä)Î°ú Ìä∏Î¶¨Î∞çÏùÑ Ïã§ÌñâÌï©ÎãàÎã§.")

        self.status = tk.Label(body, text="ÏûÖÎ†• ÌååÏùºÏùÑ ÏÑ†ÌÉùÌïú ÌõÑ Ïã§ÌñâÌïòÏÑ∏Ïöî.", bg="#f9f9f9", fg="#333")
        self.status.pack()

        self.fig, self.ax = plt.subplots(figsize=(6.6, 2.6))
        self.canvas = FigureCanvasTkAgg(self.fig, master=body)
        self.canvas.get_tk_widget().pack(pady=10)

        self.out_paths_box = tk.Text(body, height=8, width=106)
        self.out_paths_box.configure(state="disabled")
        self.out_paths_box.pack(padx=10, pady=6)

    def select_file(self):
        path = filedialog.askopenfilename(
            title="FASTA ÎòêÎäî TXT ÌååÏùº ÏÑ†ÌÉù",
            filetypes=[("FASTA or TXT files", "*.fasta *.fa *.faa *.txt"), ("All files", "*.*")]
        )
        if path:
            self.file_path.set(path)
            self.status.config(text=f"ÏÑ†ÌÉùÎêú ÌååÏùº: {os.path.basename(path)}")

    def select_exe(self):
        path = filedialog.askopenfilename(
            title="Gblocks Ïã§ÌñâÌååÏùº ÏÑ†ÌÉù",
            filetypes=[("Executable", "*"), ("All files", "*.*")]
        )
        if path:
            self.gb_exe_path.set(path)
            self.status.config(text=f"Gblocks Ïã§ÌñâÌååÏùº: {path}")

    def run(self):
        mode = self.mode.get()
        if mode == "internal":
            self.run_internal()
        else:
            self.run_external()

    def run_internal(self):
        path = self.file_path.get()
        if not path:
            messagebox.showwarning("Í≤ΩÍ≥†", "ÏûÖÎ†• ÌååÏùºÏùÑ Î®ºÏ†Ä ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.")
            return
        try:
            mbl   = int(self.min_block_len.get())
            gap   = float(self.max_gap.get())
            cons  = float(self.min_cons.get())
            flank = float(self.flank_cons.get())

            entries = parse_fasta(path)
            nseq = len(entries)
            seq_len_before = len(entries[0][1]) if entries else 0

            trimmed = gblock_pipeline(
                entries,
                auto_align=True,
                aligner="auto",
                min_block_len=mbl,
                max_gap=gap,
                min_cons=cons,
                flank_cons=flank,
                drop_all_gap_columns=True,
            )

            params_tag = f"_m{mbl}_g{fmt_num(gap)}_c{fmt_num(cons)}_f{fmt_num(flank)}"
            base = os.path.splitext(path)[0]
            out_dir = base + params_tag
            os.makedirs(out_dir, exist_ok=True)

            out_fasta = os.path.join(out_dir, "trimmed.fasta")
            out_txt   = os.path.join(out_dir, "trimmed.txt")
            mega_fa   = os.path.join(out_dir, "trimmed_mega.fasta")
            map_txt   = os.path.join(out_dir, "label_map.txt")

            write_fasta(trimmed, out_fasta)
            with open(out_txt, "w", encoding="utf-8") as m:
                for h, seq in trimmed:
                    m.write(f">{h}\n{seq}\n")

            cleaned = [(sanitize_label(h), seq) for h, seq in trimmed]
            write_fasta(cleaned, mega_fa)
            with open(map_txt, "w", encoding="utf-8") as m:
                m.write("original\tsanitized\n")
                for (h, _), (hh, _) in zip(trimmed, cleaned):
                    m.write(f"{h}\t{hh}\n")

            seq_len_after = len(trimmed[0][1]) if trimmed else 0
            reduction = (1 - seq_len_after / max(1, seq_len_before)) * 100.0
            self._plot(seq_len_before, seq_len_after, nseq)

            self.status.config(
                text=f"‚úÖ Ïã§Ìñâ ÏôÑÎ£å ({seq_len_before} ‚Üí {seq_len_after}, -{reduction:.1f}%)\n"
                    f"Ìè¥Îçî: {os.path.basename(out_dir)}"
            )
            self._write_paths([
                ("FASTA (ÏõêÎ≥∏ ÎùºÎ≤®)", out_fasta),
                ("TXT", out_txt),
                ("MEGAÏö© FASTA (Ïù¥Î¶ÑÎßå)", mega_fa),
                ("ÎùºÎ≤® Îß§Ìïë", map_txt),
            ])

        except Exception as e:
            messagebox.showerror("ÏóêÎü¨", str(e))
            self.status.config(text="‚ùå Ïò§Î•ò")

    def run_external(self):
        path_in = self.file_path.get()
        exe  = self.gb_exe_path.get()
        if not path_in:
            messagebox.showwarning("Í≤ΩÍ≥†", "ÏûÖÎ†• ÌååÏùºÏùÑ Î®ºÏ†Ä ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.")
            return
        if not exe or not os.path.isfile(exe):
            messagebox.showwarning("Í≤ΩÍ≥†", "Gblocks Ïã§ÌñâÌååÏùº Í≤ΩÎ°úÎ•º ÏßÄÏ†ïÌïòÏÑ∏Ïöî.")
            return

        workdir = os.path.dirname(os.path.abspath(path_in)) or "."
        path_src, tmp_txt_copy = ensure_fasta_for_gblocks(path_in)

        aligned_tmp = None
        pir_tmp = None
        try:
            entries = parse_fasta(path_src)
            aligned = auto_align_if_needed(entries, aligner="auto", fallback_align=True)
            aligned_tmp = os.path.splitext(path_src)[0] + "_tmp_aligned_for_gblocks.fasta"
            write_fasta(aligned, aligned_tmp, wrap=0)

            pir_tmp = os.path.splitext(path_src)[0] + "_tmp_aligned_for_gblocks.pir"
            write_pir_alignment(aligned, pir_tmp)

            t_letter = (self.gb_t.get() or "").strip().lower()
            if t_letter not in ("p", "d"):
                t_letter = detect_data_type_by_chars(aligned_tmp)

            N = len(aligned)
            b1 = min(int(self.gb_b1.get()), N)
            b2 = min(int(self.gb_b2.get()), N)
            if b1 > b2:
                b1 = b2
            b3 = int(self.gb_b3.get())
            b4 = int(self.gb_b4.get())
            b5_letter = map_b5_to_letter(self.gb_b5_mode.get())

            pir_arg = os.path.basename(pir_tmp)
            cmd = [exe, pir_arg, f"-t={t_letter}", f"-b1={b1}", f"-b2={b2}",
                f"-b3={b3}", f"-b4={b4}", f"-b5={b5_letter}"]
            completed = subprocess.run(cmd, cwd=workdir,
                                    stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

            gb_out = find_gblocks_output(os.path.join(workdir, pir_arg))
            if not gb_out:
                err_txt = (
                    "Gblocks Ïã§Ìñâ Ïã§Ìå®\n\n"
                    f"rc={completed.returncode}\n"
                    f"STDOUT:\n{completed.stdout}\n\nSTDERR:\n{completed.stderr}\n"
                )
                raise RuntimeError(err_txt)

            if gb_out.lower().endswith((".htm", ".html")):
                raise RuntimeError(
                    "Ïù¥ Gblocks Î∞∞Ìè¨Î≥∏ÏùÄ HTMLÎßå ÏÉùÏÑ±Ìï©ÎãàÎã§.\n"
                    "ÌÖçÏä§Ìä∏ Í≤∞Í≥ºÍ∞Ä ÌïÑÏöîÌïú Í≤ΩÏö∞ Îã§Î•∏ Gblocks Ïã§ÌñâÌååÏùºÏùÑ ÏÇ¨Ïö©ÌïòÏÑ∏Ïöî."
                )

            trimmed = parse_fasta(gb_out)
            seq_len_before = len(aligned[0][1]) if aligned else 0
            seq_len_after  = len(trimmed[0][1]) if trimmed else 0
            reduction = (1 - (seq_len_after / max(1, seq_len_before))) * 100.0

            btag = f"_GB_t{t_letter}_b1{b1}_b2{b2}_b3{b3}_b4{b4}_b5{b5_letter}"
            base = os.path.splitext(path_in)[0]
            out_dir = base + btag
            os.makedirs(out_dir, exist_ok=True)

            out_fasta = os.path.join(out_dir, "trimmed.fasta")
            out_txt   = os.path.join(out_dir, "trimmed.txt")
            mega_fa   = os.path.join(out_dir, "trimmed_mega.fasta")
            map_txt   = os.path.join(out_dir, "label_map.txt")
            gb_raw_copy = os.path.join(out_dir, os.path.basename(gb_out))
            try:
                shutil.copy(gb_out, gb_raw_copy)
            except Exception:
                gb_raw_copy = gb_out

            write_fasta(trimmed, out_fasta)
            with open(out_txt, "w", encoding="utf-8") as m:
                for h, seq in trimmed:
                    m.write(f">{h}\n{seq}\n")

            cleaned = [(sanitize_label(h), seq) for h, seq in trimmed]
            write_fasta(cleaned, mega_fa)
            with open(map_txt, "w", encoding="utf-8") as m:
                m.write("original\tsanitized\n")
                for (h, _), (hh, _) in zip(trimmed, cleaned):
                    m.write(f"{h}\t{hh}\n")

            self._plot(seq_len_before, seq_len_after, len(aligned))
            summary = completed.stdout.strip()
            if summary:
                self.status.config(
                    text=f"‚úÖ Gblocks ÏôÑÎ£å ‚Äî {seq_len_before} ‚Üí {seq_len_after} (-{reduction:.1f}%)\n"
                        f"{summary}\nÌè¥Îçî: {os.path.basename(out_dir)}"
                )
            else:
                self.status.config(
                    text=f"‚úÖ Gblocks ÏôÑÎ£å ‚Äî {seq_len_before} ‚Üí {seq_len_after} (-{reduction:.1f}%)\n"
                        f"Ìè¥Îçî: {os.path.basename(out_dir)}"
                )

            self._write_paths([
                ("FASTA (ÏõêÎ≥∏ ÎùºÎ≤®)", out_fasta),
                ("TXT", out_txt),
                ("MEGAÏö© FASTA (Ïù¥Î¶ÑÎßå)", mega_fa),
                ("ÎùºÎ≤® Îß§Ìïë", map_txt),
                ("ÏõêÎ≥∏ Gblocks Ï∂úÎ†•(Ï∞∏Ï°∞)", gb_raw_copy),
            ])

        except Exception as e:
            messagebox.showerror("ÏóêÎü¨", str(e))
            self.status.config(text="‚ùå Gblocks Ïã§Ìñâ Ïò§Î•ò")
        finally:
            for tmp in (tmp_txt_copy, aligned_tmp, pir_tmp):
                try:
                    if tmp and os.path.isfile(tmp):
                        os.remove(tmp)
                except Exception:
                    pass


    # ---------- ÏãúÍ∞ÅÌôî/Í≤ΩÎ°ú Ï∂úÎ†• ----------
    def _plot(self, before_len, after_len, nseq):
        self.ax.clear()
        self.ax.bar(["Before", "After"], [before_len, after_len], color=["#FF7043", "#66BB6A"])
        self.ax.set_ylabel("Sequence Length")
        self.ax.set_title(f"{nseq} sequences processed")
        self.canvas.draw()

    def _write_paths(self, items):
        self.out_paths_box.configure(state="normal")
        self.out_paths_box.delete("1.0", "end")
        for label, p in items:
            self.out_paths_box.insert("end", f"{label}: {os.path.abspath(p)}\n")
        self.out_paths_box.configure(state="disabled")


if __name__ == "__main__":
    try:
        import matplotlib
        matplotlib.use("TkAgg")
    except Exception:
        pass
    root = tk.Tk()
    app = GblockApp(root)
    root.mainloop()