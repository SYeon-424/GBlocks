import os
import re
import shutil
import subprocess
import tkinter as tk
from tkinter import filedialog, messagebox
from gblock import parse_fasta, gblock_pipeline, write_fasta, auto_align_if_needed  # ← auto_align_if_needed 추가
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

class ToolTip:
    def __init__(self, widget, text, delay_ms: int = 200):
        self.widget = widget
        self.text = text
        self.delay_ms = delay_ms
        self.tipwindow = None
        self._after_id = None
        widget.bind("<Enter>", self._schedule)
        widget.bind("<Leave>", self._cancel)

    def _schedule(self, _event=None):
        self._after_id = self.widget.after(self.delay_ms, self.show_tip)

    def _cancel(self, _event=None):
        if self._after_id:
            try:
                self.widget.after_cancel(self._after_id)
            except Exception:
                pass
            self._after_id = None
        self.hide_tip()

    def show_tip(self, event=None):
        if self.tipwindow or not self.text:
            return
        x = self.widget.winfo_rootx() + 25
        y = self.widget.winfo_rooty() + self.widget.winfo_height() + 5
        self.tipwindow = tw = tk.Toplevel(self.widget)
        tw.wm_overrideredirect(True)
        tw.wm_geometry(f"+{x}+{y}")
        label = tk.Label(
            tw,
            text=self.text,
            justify="left",
            background="#ffffe0",
            relief="solid",
            borderwidth=1,
            font=("맑은 고딕", 9),
            padx=6,
            pady=4,
            wraplength=360,
        )
        label.pack()

    def hide_tip(self, event=None):
        if self.tipwindow:
            try:
                self.tipwindow.destroy()
            except Exception:
                pass
            self.tipwindow = None

def create_tooltip(widget, text, delay_ms: int = 200):
    ToolTip(widget, text, delay_ms=delay_ms)

def write_txt(entries, path: str) -> None:
    with open(path, "w", encoding="utf-8") as out:
        for h, seq in entries:
            out.write(f">{h}\n{seq}\n")

def sanitize_label(header: str) -> str:
    """
    라벨 정리
    """
    token = header.split()[0]
    token = re.sub(r"[^A-Za-z0-9._-]+", "", token)
    return token or "seq"

def write_pir_alignment(entries, path: str):
    """
    PIR(NBRF) 포맷으로 저장.
    > 공식 GBlocks용용
    """
    with open(path, "w", encoding="utf-8") as f:
        for h, seq in entries:
            label = sanitize_label(h)
            f.write(f">P1;{label}\n")
            f.write("generated by gblocks-gui\n")
            s = seq.upper()
            for i in range(0, len(s), 60):
                f.write(s[i:i+60] + "\n")
            f.write("*\n")

def fmt_num(x: float) -> str:
    """
    파일명용 실수 포맷(최대 소수점 2자리, 뒤 0 제거)
    """
    s = f"{x:.2f}"
    s = s.rstrip("0").rstrip(".")
    return s if s else "0"

def map_b5_to_letter(mode: str) -> str:
    """
    GUI의 Gap Allowed 모드 매핑
    """
    mode = (mode or "").lower()
    if mode in ("none", "n"): return "n"
    if mode in ("half", "h"): return "h"
    if mode in ("all", "a"):  return "a"
    return "h"

def detect_data_type_by_chars(path: str) -> str:
    """
    파일 내용을 통해 DNA(d) / Protein(p) 자동 판정.
    - DNA: A C G T N (그리고 gap '-') 만 주로 있으면 d
    - 그 외 문자가 섞이면 p
    """
    dna = set("ACGTN-")
    aa  = set("ABCDEFGHIKLMNPQRSTVWY-")  # 표준 아미노산
    dna_count = aa_count = other = 0
    try:
        with open(path, encoding="utf-8") as f:
            for line in f:
                s = line.strip().upper()
                if not s or s.startswith(">"):
                    continue
                for ch in s:
                    if ch in dna: dna_count += 1
                    elif ch in aa: aa_count += 1
                    else: other += 1
    except Exception:
        pass
    if dna_count > 0 and aa_count == 0 and other == 0:
        return "d"
    if aa_count > dna_count:
        return "p"
    return "p"

def find_gblocks_output(input_path: str) -> str | None:
    """
    Gblocks가 생성할 수 있는 다양한 후보 이름을 모두 검사해서
    첫 번째로 존재하는 경로를 반환. 없으면 None.
    """
    base = input_path
    stem, ext = os.path.splitext(base)
    candidates = [
        base + "-gb",
        base + "-gb.fasta",
        base + "-gb.fa",
        base + "-gb.faa",
        base + "-gb.txt",
        stem + "-gb" + ext,
        stem + "-gb.fasta",
        stem + "-gb.fa",
        stem + "-gb.faa",
        stem + "-gb.txt",
        base + "-gb.htm",
        stem + "-gb.htm",
    ]
    for c in candidates:
        if os.path.isfile(c):
            return c
    return None

def ensure_fasta_for_gblocks(src_path: str) -> tuple[str, str | None]:
    """
    .txt 선택 시 FASTA 헤더(>...)가 보이면 _tmp_for_gblocks.fasta 로 복사해
    그 경로를 반환. 원본이 이미 .fasta 계열이면 그대로 반환.
    """
    base, ext = os.path.splitext(src_path)
    if ext.lower() != ".txt":
        return src_path, None
    try:
        with open(src_path, encoding="utf-8") as f:
            first = f.readline().strip()
        if first.startswith(">"):
            tmp = base + "_tmp_for_gblocks.fasta"
            shutil.copy(src_path, tmp)
            return tmp, tmp
    except Exception:
        pass
    return src_path, None

# =========================
# GUI
# =========================
class GblockApp:
    def __init__(self, master):
        self.master = master
        master.title("Gblocks GUI — Internal / External (Official Gblocks)")
        master.geometry("900x800")
        master.configure(bg="#f9f9f9")

        container = tk.Frame(master, bg="#f9f9f9")
        container.pack(fill="both", expand=True)

        canvas = tk.Canvas(container, bg="#f9f9f9", highlightthickness=0)
        vscroll = tk.Scrollbar(container, orient="vertical", command=canvas.yview)
        canvas.configure(yscrollcommand=vscroll.set)

        vscroll.pack(side="right", fill="y")
        canvas.pack(side="left", fill="both", expand=True)

        self.scrollable_frame = tk.Frame(canvas, bg="#f9f9f9")
        canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")

        def _update_scrollregion(_e=None):
            canvas.configure(scrollregion=canvas.bbox("all"))
        self.scrollable_frame.bind("<Configure>", _update_scrollregion)

        def _on_mousewheel(event):
            delta = event.delta
            if delta != 0:
                canvas.yview_scroll(int(-delta / 120), "units")
        canvas.bind_all("<MouseWheel>", _on_mousewheel)
        canvas.bind_all("<Button-4>", lambda e: canvas.yview_scroll(-1, "units"))  # Linux up
        canvas.bind_all("<Button-5>", lambda e: canvas.yview_scroll( 1, "units"))  # Linux down

        body = self.scrollable_frame

        title = tk.Label(
            body,
            text="🧬 Gblocks-like Trimmer • Internal & External (Official Gblocks)",
            font=("Helvetica", 16, "bold"),
            bg="#f9f9f9",
        )
        title.pack(pady=12)

        mode_frame = tk.Frame(body, bg="#f9f9f9")
        mode_frame.pack(pady=2)
        self.mode = tk.StringVar(value="internal")
        tk.Radiobutton(mode_frame, text="내장 트리머 (Python)",
                       variable=self.mode, value="internal", bg="#f9f9f9").pack(side=tk.LEFT, padx=8)
        tk.Radiobutton(mode_frame, text="공식 Gblocks 실행파일",
                       variable=self.mode, value="external", bg="#f9f9f9").pack(side=tk.LEFT, padx=8)

        self.file_path = tk.StringVar()
        frm_file = tk.Frame(body, bg="#f9f9f9")
        frm_file.pack(pady=6)
        ent_file = tk.Entry(frm_file, textvariable=self.file_path, width=64, state="readonly")
        ent_file.pack(side=tk.LEFT, padx=6)
        btn_file = tk.Button(frm_file, text="입력 파일 선택", command=self.select_file)
        btn_file.pack(side=tk.LEFT)
        create_tooltip(ent_file, "정렬 전/후의 FASTA 또는 TXT 파일을 선택하세요. (필수)")

        exe_frame = tk.Frame(body, bg="#f9f9f9")
        exe_frame.pack(pady=4)
        self.gb_exe_path = tk.StringVar()
        ent_exe = tk.Entry(exe_frame, textvariable=self.gb_exe_path, width=64, state="readonly")
        ent_exe.pack(side=tk.LEFT, padx=6)
        btn_exe = tk.Button(exe_frame, text="Gblocks 실행파일 선택", command=self.select_exe)
        btn_exe.pack(side=tk.LEFT)
        create_tooltip(ent_exe, "공식 Gblocks 실행파일 경로 (예: /usr/local/bin/Gblocks 또는 Gblocks.exe)")

        frm_internal = tk.LabelFrame(body, text="내장 트리머 파라미터 (내장 트리머 선택 시 적용)", bg="#f9f9f9")
        frm_internal.pack(pady=8, padx=10, fill="x")

        self.min_block_len = tk.IntVar(value=5)
        self.max_gap       = tk.DoubleVar(value=0.7)
        self.min_cons      = tk.DoubleVar(value=0.5)
        self.flank_cons    = tk.DoubleVar(value=0.4)

        iparams = [
            ("연속된 보존 구간 최소 길이", self.min_block_len,
             "비슷한 염기(또는 아미노산)가 몇 개 이상 연속될 때를\n'하나의 보존 구간'으로 볼지 정합니다.\n값이 클수록 더 긴 구간만 남습니다."),
            ("gap 허용 정도 (0~1)", self.max_gap,
             "정렬된 서열에서 '-'(빈칸, gap)을 얼마나 허용할지 정합니다.\n0이면 gap이 있으면 바로 제외, 1이면 gap이 많아도 통과합니다."),
            ("보존 비율 (0~1)", self.min_cons,
             "각 위치(열)에서 같은 문자가 나올 비율이\n얼마 이상일 때 '보존된 칼럼'으로 인정할지 정합니다.\n예: 0.5 → 50% 이상이 같아야 통과."),
            ("양쪽 끝부분 품질 (0~1)", self.flank_cons,
             "보존 구간의 시작과 끝이 얼마나 안정적인지를 확인합니다.\n값이 높을수록 경계가 더 깔끔한 구간만 남습니다."),
        ]

        for label, var, tip in iparams:
            row = tk.Frame(frm_internal, bg="#f9f9f9")
            row.pack(fill="x", pady=2)
            lbl = tk.Label(row, text=label, width=28, anchor="w", bg="#f9f9f9")
            lbl.pack(side=tk.LEFT, padx=10)
            ent = tk.Entry(row, textvariable=var, width=10)
            ent.pack(side=tk.LEFT)
            create_tooltip(lbl, tip); create_tooltip(ent, tip)

        frm_external = tk.LabelFrame(body, text="공식 Gblocks 파라미터 (공식 Gblocks 선택 시 적용)", bg="#f9f9f9")
        frm_external.pack(pady=8, padx=10, fill="x")

        self.gb_t = tk.StringVar(value="")
        rowt = tk.Frame(frm_external, bg="#f9f9f9"); rowt.pack(fill="x", pady=2)
        tk.Label(rowt, text="Data type (-t)", width=28, anchor="w", bg="#f9f9f9").pack(side=tk.LEFT, padx=10)
        type_menu = tk.OptionMenu(rowt, self.gb_t, "", "p", "d")
        type_menu.pack(side=tk.LEFT)
        create_tooltip(rowt, "데이터 타입. p=단백질, d=DNA. (비워두면 자동으로 판정됩니다.)")

        self.gb_b1 = tk.IntVar(value=9)
        self.gb_b2 = tk.IntVar(value=14)
        self.gb_b3 = tk.IntVar(value=8)
        self.gb_b4 = tk.IntVar(value=10)
        self.gb_b5_mode = tk.StringVar(value="Half")

        def spin_row(parent, label, var, tip):
            r = tk.Frame(parent, bg="#f9f9f9"); r.pack(fill="x", pady=2)
            tk.Label(r, text=label, width=28, anchor="w", bg="#f9f9f9").pack(side=tk.LEFT, padx=10)
            sp = tk.Spinbox(r, from_=0, to=9999, textvariable=var, width=8)
            sp.pack(side=tk.LEFT)
            create_tooltip(sp, tip); create_tooltip(r, tip)

        spin_row(frm_external, "b1 (Min # for Conserved)", self.gb_b1,
                 "한 위치(칼럼)가 '보존된 자리'로 인정되기 위한 최소 서열 개수입니다.\n"
                 "예: 20개 중 15개가 같은 문자인 경우 → 15 이상이면 보존으로 간주.")
        spin_row(frm_external, "b2 (Min # for Flanking)", self.gb_b2,
                 "보존 블록의 시작과 끝(경계 부분)을 보존된 것으로\n인정하기 위한 최소 서열 개수입니다.\n"
                 "b1보다 같거나 커야 합니다.")
        spin_row(frm_external, "b3 (Max contiguous non-conserved)", self.gb_b3,
                 "비슷하지 않은(보존되지 않은) 자리가 연속으로\n최대 몇 개까지 허용되는지를 정합니다.\n"
                 "값이 크면 덜 보존된 구간도 포함됩니다.")
        spin_row(frm_external, "b4 (Minimum block length)", self.gb_b4,
                 "하나의 보존 블록으로 인정되려면 최소 몇 개의 칼럼이\n연속되어야 하는지를 정합니다.\n"
                 "짧을수록 블록이 잘게 나뉘고, 길수록 큰 덩어리만 남습니다.")

        rowb5 = tk.Frame(frm_external, bg="#f9f9f9"); rowb5.pack(fill="x", pady=2)
        tk.Label(rowb5, text="b5 (Allowed Gap Positions)", width=28, anchor="w", bg="#f9f9f9").pack(side=tk.LEFT, padx=10)
        tk.OptionMenu(rowb5, self.gb_b5_mode, "None", "Half", "All").pack(side=tk.LEFT)
        create_tooltip(rowb5,
            "갭('-')이 포함된 칼럼을 어느 정도 허용할지 정합니다.\n"
            "• None: 갭이 있으면 바로 제외\n"
            "• Half: 절반 정도까진 허용\n"
            "• All: 대부분 갭이어도 허용")

        btn_run = tk.Button(body, text="실행", command=self.run,
                            bg="#4CAF50", fg="white", font=("Helvetica", 11, "bold"))
        btn_run.pack(pady=12)
        create_tooltip(btn_run, "선택한 모드(내장/외부)로 트리밍을 실행합니다.")

        self.status = tk.Label(body, text="입력 파일을 선택한 후 실행하세요.", bg="#f9f9f9", fg="#333")
        self.status.pack()

        self.fig, self.ax = plt.subplots(figsize=(6.6, 2.6))
        self.canvas = FigureCanvasTkAgg(self.fig, master=body)
        self.canvas.get_tk_widget().pack(pady=10)

        self.out_paths_box = tk.Text(body, height=8, width=106)
        self.out_paths_box.configure(state="disabled")
        self.out_paths_box.pack(padx=10, pady=6)

    def select_file(self):
        path = filedialog.askopenfilename(
            title="FASTA 또는 TXT 파일 선택",
            filetypes=[("FASTA or TXT files", "*.fasta *.fa *.faa *.txt"), ("All files", "*.*")]
        )
        if path:
            self.file_path.set(path)
            self.status.config(text=f"선택된 파일: {os.path.basename(path)}")

    def select_exe(self):
        path = filedialog.askopenfilename(
            title="Gblocks 실행파일 선택",
            filetypes=[("Executable", "*"), ("All files", "*.*")]
        )
        if path:
            self.gb_exe_path.set(path)
            self.status.config(text=f"Gblocks 실행파일: {path}")

    def run(self):
        mode = self.mode.get()
        if mode == "internal":
            self.run_internal()
        else:
            self.run_external()

    def run_internal(self):
        path = self.file_path.get()
        if not path:
            messagebox.showwarning("경고", "입력 파일을 먼저 선택하세요.")
            return
        try:
            mbl   = int(self.min_block_len.get())
            gap   = float(self.max_gap.get())
            cons  = float(self.min_cons.get())
            flank = float(self.flank_cons.get())

            entries = parse_fasta(path)
            nseq = len(entries)
            seq_len_before = len(entries[0][1]) if entries else 0

            trimmed = gblock_pipeline(
                entries,
                auto_align=True,
                aligner="auto",
                min_block_len=mbl,
                max_gap=gap,
                min_cons=cons,
                flank_cons=flank,
                drop_all_gap_columns=True,
            )

            params_tag = f"_m{mbl}_g{fmt_num(gap)}_c{fmt_num(cons)}_f{fmt_num(flank)}"
            base = os.path.splitext(path)[0]
            out_dir = base + params_tag
            os.makedirs(out_dir, exist_ok=True)

            out_fasta = os.path.join(out_dir, "trimmed.fasta")
            out_txt   = os.path.join(out_dir, "trimmed.txt")
            mega_fa   = os.path.join(out_dir, "trimmed_mega.fasta")
            map_txt   = os.path.join(out_dir, "label_map.txt")

            write_fasta(trimmed, out_fasta)
            with open(out_txt, "w", encoding="utf-8") as m:
                for h, seq in trimmed:
                    m.write(f">{h}\n{seq}\n")

            cleaned = [(sanitize_label(h), seq) for h, seq in trimmed]
            write_fasta(cleaned, mega_fa)
            with open(map_txt, "w", encoding="utf-8") as m:
                m.write("original\tsanitized\n")
                for (h, _), (hh, _) in zip(trimmed, cleaned):
                    m.write(f"{h}\t{hh}\n")

            seq_len_after = len(trimmed[0][1]) if trimmed else 0
            reduction = (1 - seq_len_after / max(1, seq_len_before)) * 100.0
            self._plot(seq_len_before, seq_len_after, nseq)

            self.status.config(
                text=f"✅ 실행 완료 ({seq_len_before} → {seq_len_after}, -{reduction:.1f}%)\n"
                    f"폴더: {os.path.basename(out_dir)}"
            )
            self._write_paths([
                ("FASTA (원본 라벨)", out_fasta),
                ("TXT", out_txt),
                ("MEGA용 FASTA (이름만)", mega_fa),
                ("라벨 매핑", map_txt),
            ])

        except Exception as e:
            messagebox.showerror("에러", str(e))
            self.status.config(text="❌ 오류")

    def run_external(self):
        path_in = self.file_path.get()
        exe  = self.gb_exe_path.get()
        if not path_in:
            messagebox.showwarning("경고", "입력 파일을 먼저 선택하세요.")
            return
        if not exe or not os.path.isfile(exe):
            messagebox.showwarning("경고", "Gblocks 실행파일 경로를 지정하세요.")
            return

        workdir = os.path.dirname(os.path.abspath(path_in)) or "."
        path_src, tmp_txt_copy = ensure_fasta_for_gblocks(path_in)

        aligned_tmp = None
        pir_tmp = None
        try:
            entries = parse_fasta(path_src)
            aligned = auto_align_if_needed(entries, aligner="auto", fallback_align=True)
            aligned_tmp = os.path.splitext(path_src)[0] + "_tmp_aligned_for_gblocks.fasta"
            write_fasta(aligned, aligned_tmp, wrap=0)

            pir_tmp = os.path.splitext(path_src)[0] + "_tmp_aligned_for_gblocks.pir"
            write_pir_alignment(aligned, pir_tmp)

            t_letter = (self.gb_t.get() or "").strip().lower()
            if t_letter not in ("p", "d"):
                t_letter = detect_data_type_by_chars(aligned_tmp)

            N = len(aligned)
            b1 = min(int(self.gb_b1.get()), N)
            b2 = min(int(self.gb_b2.get()), N)
            if b1 > b2:
                b1 = b2
            b3 = int(self.gb_b3.get())
            b4 = int(self.gb_b4.get())
            b5_letter = map_b5_to_letter(self.gb_b5_mode.get())

            pir_arg = os.path.basename(pir_tmp)
            cmd = [exe, pir_arg, f"-t={t_letter}", f"-b1={b1}", f"-b2={b2}",
                f"-b3={b3}", f"-b4={b4}", f"-b5={b5_letter}"]
            completed = subprocess.run(cmd, cwd=workdir,
                                    stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

            gb_out = find_gblocks_output(os.path.join(workdir, pir_arg))
            if not gb_out:
                err_txt = (
                    "Gblocks 실행 실패\n\n"
                    f"rc={completed.returncode}\n"
                    f"STDOUT:\n{completed.stdout}\n\nSTDERR:\n{completed.stderr}\n"
                )
                raise RuntimeError(err_txt)

            if gb_out.lower().endswith((".htm", ".html")):
                raise RuntimeError(
                    "이 Gblocks 배포본은 HTML만 생성합니다.\n"
                    "텍스트 결과가 필요한 경우 다른 Gblocks 실행파일을 사용하세요."
                )

            trimmed = parse_fasta(gb_out)
            seq_len_before = len(aligned[0][1]) if aligned else 0
            seq_len_after  = len(trimmed[0][1]) if trimmed else 0
            reduction = (1 - (seq_len_after / max(1, seq_len_before))) * 100.0

            btag = f"_GB_t{t_letter}_b1{b1}_b2{b2}_b3{b3}_b4{b4}_b5{b5_letter}"
            base = os.path.splitext(path_in)[0]
            out_dir = base + btag
            os.makedirs(out_dir, exist_ok=True)

            out_fasta = os.path.join(out_dir, "trimmed.fasta")
            out_txt   = os.path.join(out_dir, "trimmed.txt")
            mega_fa   = os.path.join(out_dir, "trimmed_mega.fasta")
            map_txt   = os.path.join(out_dir, "label_map.txt")
            gb_raw_copy = os.path.join(out_dir, os.path.basename(gb_out))
            try:
                shutil.copy(gb_out, gb_raw_copy)
            except Exception:
                gb_raw_copy = gb_out

            write_fasta(trimmed, out_fasta)
            with open(out_txt, "w", encoding="utf-8") as m:
                for h, seq in trimmed:
                    m.write(f">{h}\n{seq}\n")

            cleaned = [(sanitize_label(h), seq) for h, seq in trimmed]
            write_fasta(cleaned, mega_fa)
            with open(map_txt, "w", encoding="utf-8") as m:
                m.write("original\tsanitized\n")
                for (h, _), (hh, _) in zip(trimmed, cleaned):
                    m.write(f"{h}\t{hh}\n")

            self._plot(seq_len_before, seq_len_after, len(aligned))
            summary = completed.stdout.strip()
            if summary:
                self.status.config(
                    text=f"✅ Gblocks 완료 — {seq_len_before} → {seq_len_after} (-{reduction:.1f}%)\n"
                        f"{summary}\n폴더: {os.path.basename(out_dir)}"
                )
            else:
                self.status.config(
                    text=f"✅ Gblocks 완료 — {seq_len_before} → {seq_len_after} (-{reduction:.1f}%)\n"
                        f"폴더: {os.path.basename(out_dir)}"
                )

            self._write_paths([
                ("FASTA (원본 라벨)", out_fasta),
                ("TXT", out_txt),
                ("MEGA용 FASTA (이름만)", mega_fa),
                ("라벨 매핑", map_txt),
                ("원본 Gblocks 출력(참조)", gb_raw_copy),
            ])

        except Exception as e:
            messagebox.showerror("에러", str(e))
            self.status.config(text="❌ Gblocks 실행 오류")
        finally:
            for tmp in (tmp_txt_copy, aligned_tmp, pir_tmp):
                try:
                    if tmp and os.path.isfile(tmp):
                        os.remove(tmp)
                except Exception:
                    pass


    # ---------- 시각화/경로 출력 ----------
    def _plot(self, before_len, after_len, nseq):
        self.ax.clear()
        self.ax.bar(["Before", "After"], [before_len, after_len], color=["#FF7043", "#66BB6A"])
        self.ax.set_ylabel("Sequence Length")
        self.ax.set_title(f"{nseq} sequences processed")
        self.canvas.draw()

    def _write_paths(self, items):
        self.out_paths_box.configure(state="normal")
        self.out_paths_box.delete("1.0", "end")
        for label, p in items:
            self.out_paths_box.insert("end", f"{label}: {os.path.abspath(p)}\n")
        self.out_paths_box.configure(state="disabled")


if __name__ == "__main__":
    try:
        import matplotlib
        matplotlib.use("TkAgg")
    except Exception:
        pass
    root = tk.Tk()
    app = GblockApp(root)
    root.mainloop()